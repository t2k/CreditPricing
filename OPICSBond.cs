using System;
using System.Collections.Generic;
using System.Linq;


namespace CreditPricing
{

    /// <summary>
    /// Summary description for OPICSBond
    /// </summary>
    public class OPICSBond
    {
        private DateTime m_evalDate;
        // yield curve revaluation date  
        private DateTime m_ProFormaDate;
        // forward P&L (Horizon) calculation Date
        private string m_Issuer;
        // a string 
        private string m_dealid;
        // OPICS specific DEAL-ID ' must be unique for each bond
        private string m_Cusip;
        // identifier (usually cusip but can be ISIN,  Identifiler
        private DateTime m_dDate;
        //3 deal traded date
        private DateTime m_sDate;
        //4  deal trades settled date value/settledate
        private DateTime m_FirstSettleDate;
        // pulled from opics/livedeal 
        private DateTime m_mDate;
        //5 maturity. date (WAL DATE)
        private DateTime m_LegalFinal;
        // legal final maturity
        private string m_port;
        // portfolio
        private string m_ccy;
        // currency
        private double m_BaseRate;
        //Index Rate  (from OPICS this is for the current stub)
        private double m_Spread;
        // Reset Margin  (current stub)
        private double m_AmtOut;
        //  Current Outstanding  (from stub flow)
        private double m_AmtOrig;
        // Original Amount on trade/settled date
        private string m_DealText;
        // text field passed in from OPICS
        private string m_ratecode;
        // ratecode ie 3MLIBOR  (an opics string)
        private string m_basis;
        //  A360, FIXED etc  Opics has peculiar values for this
        private double m_CrBPV;
        // generated by recalc... subroutine /calculated
        private double m_CrBPV_cpv;
        private double m_OrigPrice;
        // note: this has to be parsed from DealText as we are using the opics loan table not security
        private double m_ASWP_Spread;
        // NOTE: parsed from DEALTEXT in dealreplicate of wsOPICS webservice
        private double m_DM;
        // discount Margin in BASIS POINTS
        private double m_DM_CPV;
        //discount MARGIN in Basis Points from
        private string m_cpv;
        // class paydown vector
        private string m_Wrap;
        // WRAP 
        private string m_AssetClass;
        // creditNet asset class
        private string m_AssetSubClass;
        // creditnet sub-asset class
        private string m_Ticker;
        // creditnet ticker
        private string m_CouponType;
        // coupon type FRN ASW  (All FIXED bonds are swapped to 1M or 3M libor)
        private string m_Ratings;
        // current ratings string pulled of CreditNet
        private double m_PVFlows;
        // pv of cflows using DM  generated by Recalc... subroutine
        private double m_PVFlows_CPV;
        // pv of cflows using DM  generated by Recalc... subroutine
        private DateTime m_RevalSpreadDate;
        // controlling spreads date
        private ABSEvalCurve m_ABSEvalCurve;
        // MTM eval curve object (knows how to interpololate)
        private double m_FlatIndex;
        // calculated during contructor from the YC, the first forward index rate used in DM calculations
        private DateTime m_CalcTime;
        // pulled in from YC object during the yc.Recalc subroutine (actually passed from the CRealTimePrices object 
        private bool m_AmortStatus;
        // true if amortizing, false if bullet
        private mxCDSCFlows m_CashFlows;
        // booked flows from OPICS
        private mxCDSCFlows m_CashFlows_CPV;
        // generated by CPV (class paydown vector)




        /// <summary>
        /// create OPICSBond object from an OPICS DealID 03-######
        /// deal id is ##-######  (branch id + DealNo)
        /// </summary>
        /// <param name="strDealID">a string ##-######</param>
        public OPICSBond(string strDealID)
        {
            var db = new CreditPricingEntities();
            //byval ByVal rowBOND As dsCreditNet.OPICSBondsRow, ByVal dealCashFlows() As dsCreditNet.OPICSBondCashFlowsRow, ByVal cal As CCalendar, ByVal yc As CYldCurve, ByVal p_absEvalCurve As CABSEvalCurve)
            //dsCreditNetTableAdapters.RATEHISTTableAdapter ta = new dsCreditNetTableAdapters.RATEHISTTableAdapter();
            // most recent saved rates

            // use max date by default
            m_evalDate = (from r in db.RATEHISTs
                          select r.Date).Max();


            // from latest rate saved date
            //ta.Dispose();
            // query bonds by DealID param passed in...
            //dsCreditNetTableAdapters.OPICSBondTableAdapter taBond = new dsCreditNetTableAdapters.OPICSBondTableAdapter();

            //dsCreditNet.OPICSBondRow bond = taBond.GetBond(strDealID).Rows(0);
            // qry one bond
            var qry = (from b in db.OPICSLIVEDEALs
                       join s in db.SecurityCPVs on b.CUSIP equals s.CUSIP
                       join m in db.Security_Masters on b.CUSIP equals m.CUSIP
                       where b.DEALID == strDealID
                       select new
                       {
                           bond = b,
                           bondCPV = s.CPV,
                           bondABSCurve = m.ABSEvalCurveKey,
                           bondClass = m.SecurityClass,
                           bondSubClass = m.CDOType,
                           bondWrap = m.Wrap,
                           bondTICKER = m.TICKER,
                           bondRATINGS = m.SecurityRatings,
                           bondFirstSettle = m.Settlement,
                           bondLegalFinal = m.FinalMaturity,
                           bondAmortStatus = m.SecurityAmortStatus,
                           bondCF = (from cf in db.OPICSCashFlows
                                     where cf.DEALID == strDealID
                                     orderby cf.INTSTRTDTE
                                     select cf).ToList()
                       }).SingleOrDefault();

            m_cpv = qry.bondCPV;

            //try
            //{
            //    // scalar function to return CPV by dealID
            //    m_cpv = taBond.GetCPV(strDealID);
            //}
            //catch (Exception ex)
            //{
            //    m_cpv = "33";
            //}

            // create a calendar object
            Calendar cal = new Calendar(qry.bond.CCY);

            // query bondsflows by DealID param passed in...
            //dsCreditNetTableAdapters.OPICSBondCashFlowsTableAdapter taBF = new dsCreditNetTableAdapters.OPICSBondCashFlowsTableAdapter();
            //dsCreditNet.OPICSBondCashFlowsDataTable dtBF = taBF.GetBondCashFlows(strDealID);


            // get the default yield curve per currency... using locCCYDef table adapter
            //dsCreditNetTableAdapters.locCcyDefTableAdapter taCD = new dsCreditNetTableAdapters.locCcyDefTableAdapter();
            // create the correct yield curve from the bond CCY 

            YldCurve yc = new YldCurve(m_evalDate, qry.bond.CCY); // taCD.GetYldCurveName(qry.bond.CCY), m_evalDate);

            m_CalcTime = yc.ycTime;

            // cleanup stuff
            //taBF.Dispose();
            //taCD.Dispose();

            // get max abscurve date
            // dsCreditNetTableAdapters.ABSEvalCurveTableAdapter taEvalCurve = new dsCreditNetTableAdapters.ABSEvalCurveTableAdapter();
            // create an ABSEvalCurve object (it can interp)
            // 
            m_ABSEvalCurve = (from a in db.ABSEvalCurves
                              where a.ABSEvalCurveName == qry.bondABSCurve && a.EvalDate == (from z in db.ABSEvalCurves select z.EvalDate).Max()
                              select a).SingleOrDefault();


            // the flows are date ordered so this will logically workout...
            // look for stub period 
            foreach (var row in qry.bondCF) //dsCreditNet.OPICSBondCashFlowsRow row in dtBF.Rows)
            {
                if (row.INTSTRTDTE <= m_evalDate & m_evalDate < row.INTENDDTE)
                {
                    m_BaseRate = (double)row.INTRATE_8 / 100;
                    m_Spread = (double)row.SPREAD_8 / 100;
                    m_basis = row.BASIS.Trim();
                    m_ratecode = row.RATECODE.Trim();
                    m_AmtOut = (double)row.PRINAMT;
                }

                if (row.INTSTRTDTE > m_evalDate)
                {
                    m_FlatIndex = yc.FwdRate((DateTime)row.INTSTRTDTE, (DateTime)row.INTENDDTE);
                    break; // TODO: might not be correct. Was : Exit For
                }
            }

            try
            {
                m_AssetSubClass = qry.bondSubClass; // bond.AssetSubClass;
            }
            catch
            {
                m_AssetSubClass = "N/A";
            }

            try
            {
                m_Wrap = qry.bondWrap; // bond.Wrap;
            }
            catch
            {
                m_Wrap = "N/A";
            }

            try
            {
                m_Ticker = qry.bondTICKER;
            }
            catch
            {
                m_Ticker = "N/A";
            }


            try
            {
                m_AssetClass = qry.bondClass;
            }
            catch
            {
                m_AssetClass = "N/A";
            }

            if (qry.bondRATINGS == null)
            {
                m_ratecode = "N/A";
            }
            else
            {
                m_Ratings = qry.bondRATINGS;
            }

            m_Cusip = qry.bond.CUSIP;
            // new July 08  true for amortizers
            m_AmortStatus = (bool)qry.bondAmortStatus;
            m_FirstSettleDate = (DateTime)qry.bondFirstSettle;
            m_LegalFinal = (DateTime)qry.bondLegalFinal;
            m_OrigPrice = (double)qry.bond.PRICE;
            m_AmtOrig = (double)qry.bond.FACE;
            m_ccy = qry.bond.CCY;
            m_dDate = (DateTime)qry.bond.DDATE;
            m_dealid = qry.bond.DEALID;
            m_Issuer = qry.bond.SECURITY;
            //.strShortName
            m_mDate = (DateTime)qry.bond.MDATE;
            m_sDate = (DateTime)qry.bond.VDATE;
            m_DealText = qry.bond.DEALTEXT.Trim();

            if (qry.bond.ASWPSPRD != 0)
            {
                m_CouponType = "ASW";
                m_ASWP_Spread = (double)qry.bond.ASWPSPRD / 100;
                m_Spread = m_ASWP_Spread;
            }
            else if (RateCode == "FIXED")
            {
                m_CouponType = "FIX";
            }
            else
            {
                m_CouponType = "FRN";
            }

            m_DM = m_ABSEvalCurve.InterpSpread(m_mDate);
            // interp the MTM spread to the WAL MaturityDate
            m_RevalSpreadDate = m_ABSEvalCurve.EvalDate; // .CurveDate;

            // the bond cf collection is actually a CDSCFCollecton...
            if (m_CouponType == "ASW")
            {
                // this is very new and important as of June 19 2006
                m_CashFlows = new mxCDSCFlows(this, cal, yc, m_sDate);
            }
            else
            {
                m_CashFlows = new mxCDSCFlows(qry.bondCF, yc, EvalDate, (double)qry.bond.FACE);
            }
            // contructor to generate flows given the bond's CPV
            m_CashFlows_CPV = new mxCDSCFlows(this, cal, yc);
            // NOTE: After the CPV cashflows are created, we can find the interpolated dm based upon the WAL yrs generated by the CPV
            m_DM_CPV = m_ABSEvalCurve.InterpSpreadYRS(WALcpv);
            RecalcDMFlows();
        }



        // DEPRECATED.. cancelled
        //dsCreditNet.OPICSBondCashFlowsDataTable
        //dealCashFlows() As dsCreditNet.OPICSBondCashFlowsRow
        //dtMTMEval date is the date we are pricing to..
        public OPICSBond(OPICSLIVEDEAL _bond, Security_Master _bondProp, List<OPICSCashFlow> _bondCFs, Calendar _cal, YldCurve _yc, ABSEvalCurve _absEvalCurve)
        {
            m_evalDate = _yc.ValueDate;
            // date is passed in via paramater list... is is intended to be the Settlement Date
            m_cpv = "33";
            // not used
            m_CalcTime = _yc.ycTime;
            m_ABSEvalCurve = _absEvalCurve;
            // new object (FEB 08)
            // the flows are date ordered so this will logically workout...
            // look for stub period 

            m_FirstSettleDate = (DateTime)_bondProp.Settlement; // FirstSettlement;
            m_LegalFinal = (DateTime)_bondProp.FinalMaturity; // .LegalFinal;
            foreach (OPICSCashFlow row in _bondCFs)
            {
                if (row.INTSTRTDTE <= m_evalDate & m_evalDate < row.INTENDDTE)
                {
                    m_BaseRate = (double)row.INTRATE_8 / 100;
                    m_Spread = (double)row.SPREAD_8 / 100;
                    m_basis = row.BASIS.Trim();
                    m_ratecode = row.RATECODE.Trim();
                    m_AmtOut = (double)row.PPAYAMT; //.PRINAMT;
                }
                if (row.INTSTRTDTE > m_evalDate)
                {
                    m_FlatIndex = _yc.FwdRate((DateTime)row.INTSTRTDTE, (DateTime)row.INTENDDTE);
                    break; // TODO: might not be correct. Was : Exit For
                }
            }

            m_Cusip = _bond.CUSIP;


            try
            {
                m_AssetSubClass = _bondProp.CDOType; // .AssetSubClass;
            }
            catch
            {
                m_AssetSubClass = "N/A";
            }

            try
            {
                m_Wrap = _bondProp.Wrap; // .Wrap;
            }
            catch
            {
                m_Wrap = "N/A";
            }

            try
            {
                m_Ticker = _bondProp.TICKER;
            }
            catch
            {
                m_Ticker = "N/A";
            }

            try
            {
                m_AssetClass = _bondProp.SecurityClass;
            }
            catch
            {
                m_AssetClass = "N/A";
            }
            m_Ratings = _bondProp.SecurityRatings;
            m_OrigPrice = (double)_bond.PRICE;
            m_AmtOrig = (double)_bond.FACE;
            //
            m_ccy = _bond.CCY;
            m_dDate = (DateTime)_bond.DDATE;
            m_dealid = _bond.DEALID;
            m_Issuer = _bond.SECURITY.Trim();
            //.strShortName
            m_mDate = (DateTime)_bond.MDATE;
            m_sDate = (DateTime)_bond.VDATE;
            m_DealText = _bond.DEALTEXT.Trim();

            // 7/11/2006 new use the m_mtmSprd field 

            if (_bond.ASWPSPRD != 0)
            {
                m_CouponType = "ASW";
                m_ASWP_Spread = (double)_bond.ASWPSPRD / 100;
                m_Spread = m_ASWP_Spread;
            }
            else if (RateCode == "FIXED")
            {
                m_CouponType = "FIX";
            }
            else
            {
                m_CouponType = "FRN";
            }

            // this is the DM spread

            if (m_ABSEvalCurve != null)
            {
                m_DM = m_ABSEvalCurve.InterpSpread(m_mDate);
                // interp the MTM spread to the WAL MaturityDate
                m_RevalSpreadDate = m_ABSEvalCurve.EvalDate;
            }
            else
            {
                m_DM = 0;
                m_RevalSpreadDate = m_evalDate;
            }

            // the bond cf collection is actually a CDSCFCollecton...
            if (m_CouponType == "ASW")
            {
                // this is very new and important as of June 19 2006
                m_CashFlows = new mxCDSCFlows(this, _cal, _yc, m_sDate);
            }
            else
            {
                m_CashFlows = new mxCDSCFlows(_bondCFs, _yc, EvalDate, (double)_bond.FACE);
            }
            // create flows from CPV vector
            m_CashFlows_CPV = null;
            // = New mxCDSCFCollection
            m_DM_CPV = m_DM;

            RecalcDMFlows();
        }



        //create OPICS bond object from a BONDPXIntput row
        // discontinue usage 5/10
        //public OPICSBond(dsOUT.BondPXInputRow _pxInput)
        //{
        //    //Dim strTrace As String = "step0"
        //    // most recent saved rates
        //    m_evalDate = _pxInput.FinancingDate;
        //    // ta.MaxDate  ' from latest rate saved date
        //    try
        //    {
        //        // query bonds by DealID param passed in...


        //        dsCreditNetTableAdapters.OPICSBondTableAdapter taBond = new dsCreditNetTableAdapters.OPICSBondTableAdapter();
        //        //strTrace += "/step1"
        //        dsCreditNet.OPICSBondDataTable dtBond = taBond.GetBond(_pxInput.TradeID);
        //        //strTrace += "/step2"

        //        dsCreditNet.OPICSBondRow bond = (dsCreditNet.OPICSBondRow)dtBond.Rows(0);
        //        //strTrace += "/step3(" + bond.ABSEvalCurveKey + ")"

        //        m_cpv = _pxInput.CPV;

        //        // create a calendar object
        //        Calendar cal = new Calendar(bond.CCY);
        //        //strTrace += "/step4"
        //        // query bondsflows by DealID param passed in...

        //        dsCreditNet.OPICSBondCashFlowsTableAdapter taBF = new dsCreditNetTableAdapters.OPICSBondCashFlowsTableAdapter();
        //        dsCreditNet.OPICSBondCashFlowsDataTable dtBF = taBF.GetBondCashFlows(_pxInput.TradeID);
        //        //strTrace += "/step5"

        //        // get the default yield curve per currency... using locCCYDef table adapter
        //        dsCreditNetTableAdapters.locCcyDefTableAdapter taCD = new dsCreditNetTableAdapters.locCcyDefTableAdapter();
        //        //strTrace += "/step6"

        //        // create the correct yield curve from the bond CCY 
        //        CYldCurve yc = new CYldCurve(taCD.GetYldCurveName(bond.CCY), m_evalDate);
        //        //strTrace += "/step7(" + pxInput.SpreadCurveDate.ToString + ")"
        //        m_CalcTime = yc.ycTime;

        //        // cleanup stuff
        //        taBF.Dispose();
        //        taCD.Dispose();

        //        // get max abscurve date
        //        //Dim taEvalCurve As New dsCreditNetTableAdapters.ABSEvalCurveTableAdapter
        //        // create an ABSEvalCurve object (it can interp)
        //        //this next call was throwing an error internally
        //        m_ABSEvalCurve = new CABSEvalCurve(_pxInput.SpreadCurveDate, bond.ABSEvalCurveKey);

        //        //strTrace += "/step8"


        //        // the flows are date ordered so this will logically workout...
        //        // look for stub period 
        //        foreach (dsCreditNet.OPICSBondCashFlowsRow row in dtBF.Rows)
        //        {
        //            if (row.INTSTRTDTE <= m_evalDate & m_evalDate < row.INTENDDTE)
        //            {
        //                m_BaseRate = (double)row.INTRATE_8 / 100;
        //                m_Spread = (double)row.SPREAD_8 / 100;
        //                m_basis = row.BASIS.Trim;
        //                m_ratecode = row.RATECODE.Trim;
        //                m_AmtOut = row.PRINAMT;
        //            }

        //            if (row.INTSTRTDTE > m_evalDate)
        //            {
        //                m_FlatIndex = yc.FwdRate(row.INTSTRTDTE, row.INTENDDTE);
        //                break; // TODO: might not be correct. Was : Exit For
        //            }
        //        }



        //        try
        //        {
        //            m_AssetSubClass = bond.AssetSubClass;
        //        }
        //        catch (Exception ex)
        //        {
        //            m_AssetSubClass = "N/A";
        //        }

        //        try
        //        {
        //            m_Wrap = bond.Wrap;
        //        }
        //        catch (Exception ex)
        //        {
        //            m_Wrap = "N/A";
        //        }

        //        try
        //        {
        //            m_Ticker = bond.TICKER;
        //        }
        //        catch (Exception ex)
        //        {
        //            m_Ticker = "N/A";
        //        }


        //        try
        //        {
        //            m_AssetClass = bond.AssetClass;
        //        }
        //        catch (Exception ex)
        //        {
        //            m_AssetClass = "N/A";
        //        }

        //        if (bond.SecurityRatings == System.DBNull.Value)
        //        {
        //            m_ratecode = "N/A";
        //        }
        //        else
        //        {
        //            m_Ratings = bond.SecurityRatings;
        //        }

        //        m_Cusip = bond.CUSIP;
        //        m_AmortStatus = bond.SecurityAmortStatus;
        //        m_FirstSettleDate = bond.FirstSettlement;
        //        m_LegalFinal = bond.LegalFinal;
        //        m_OrigPrice = bond.PRICE;
        //        m_AmtOrig = bond.FACE;
        //        m_ccy = bond.CCY;
        //        m_dDate = bond.DDATE;
        //        m_dealid = bond.DEALID;
        //        m_Issuer = bond.SECURITY.Trim;
        //        //.strShortName
        //        m_mDate = bond.MDATE;
        //        m_sDate = bond.VDATE;
        //        m_DealText = bond.DEALTEXT.Trim;

        //        if (bond.ASWPSPRD != 0)
        //        {
        //            m_CouponType = "ASW";
        //            m_ASWP_Spread = bond.ASWPSPRD / 100;
        //            m_Spread = m_ASWP_Spread;
        //        }
        //        else if (RateCode == "FIXED")
        //        {
        //            m_CouponType = "FIX";
        //        }
        //        else
        //        {
        //            m_CouponType = "FRN";
        //        }

        //        if (_pxInput.DMAutoInterp == true)
        //        {
        //            // interp the MTM spread to the WAL MaturityDate
        //            m_DM = m_ABSEvalCurve.InterpSpread(m_mDate);
        //        }
        //        else
        //        {
        //            m_DM = _pxInput.DM;
        //        }
        //        m_RevalSpreadDate = m_ABSEvalCurve.EvalDate;

        //        // the bond cf collection is actually a CDSCFCollecton...
        //        if (m_CouponType == "ASW")
        //        {
        //            // this is very new and important as of June 19 2006
        //            m_CashFlows = new mxCDSCFlows(this, cal, yc, m_sDate);
        //        }
        //        else
        //        {
        //            m_CashFlows = new mxCDSCFlows(dtBF, yc, EvalDate);
        //        }

        //        // contructor to generate flows given the bond's CPV
        //        m_CashFlows_CPV = new mxCDSCFlows(this, cal, yc);

        //        // NOTE: After the CPV cashflows are created, we can find the interpolated dm based upon the WAL yrs generated by the CPV
        //        if (_pxInput.DMAutoInterp == true)
        //        {
        //            m_DM_CPV = m_ABSEvalCurve.InterpSpreadYRS(WALcpv);
        //        }
        //        else
        //        {
        //            m_DM_CPV = _pxInput.DM_CPV;
        //        }
        //        RecalcDMFlows();
        //    }
        //    catch (Exception ex)
        //    {
        //        throw new ApplicationException(string.Format("Error inside: OPICSBond(BondPXInputRow): {0}", ex.Message));
        //    }
        //}



        // tranche pricing...
        // Create bond object for Quick Tranche Pricing, assume 3M FLOATING RATE
        public OPICSBond(int _TTNo, DateTime _RevalDate, double _parPremium)
        {
            //Dim ta As New dsCreditNetTableAdapters.RATEHISTTableAdapter
            // most recent saved rates
            m_evalDate = _RevalDate;
            //pxInput.FinancingDate ' ta.MaxDate  ' from latest rate saved date
            // query bonds by DealID param passed in...
            var db = new CreditPricingEntities();

            var ttRow = (from t in db.TrancheTrades
                         where t.TTNo == _TTNo
                         select t).SingleOrDefault();

            //dsCreditNetTableAdapters.TrancheTradeTableAdapter taTrancheTrade = new dsCreditNetTableAdapters.TrancheTradeTableAdapter();
            //dsCreditNet.TrancheTradeRow ttRow = taTrancheTrade.GetDataByTTNo(_TTNo).Rows(0);
            //.GetBond(pxInput.TradeID).Rows(0)

            m_cpv = "33";

            // create a calendar object
            Calendar cal = new Calendar(ttRow.CCY);

            // get the default yield curve per currency... using locCCYDef table adapter
            //dsCreditNetTableAdapters.locCcyDefTableAdapter taCD = new dsCreditNetTableAdapters.locCcyDefTableAdapter();

            // create the correct yield curve from the bond CCY and revaldate
            YldCurve yc = new YldCurve(m_evalDate, ttRow.CCY);

            m_CalcTime = yc.ycTime;

            m_Spread = (double)ttRow.Premium / 10000;
            //CDbl(row.SPREAD_8 / 100)
            m_basis = ttRow.PremBasis;
            m_ratecode = ttRow.PremPmtPA.ToString();
            //row.RATECODE.Trim
            m_AmtOut = (double)ttRow.Notional;
            // * 10 ^ 6


            // 3M cashrate
            m_FlatIndex = yc.FwdRate(this.m_evalDate, cal.FarDate(m_evalDate, "3M"));
            m_BaseRate = m_FlatIndex;


            // the flows are date ordered so this will logically workout...

            m_AssetSubClass = "Tranche";


            m_Wrap = "N/A";
            m_Ticker = "N/A";


            m_AssetClass = "Tranche";
            m_ratecode = "N/A";

            m_Cusip = "N/A";
            // bond.CUSIP
            m_AmortStatus = false;
            // bond.SecurityAmortStatus
            m_FirstSettleDate = m_evalDate;
            // bond.FirstSettlement
            m_LegalFinal = (DateTime)ttRow.Maturity;
            // bond.LegalFinal
            m_OrigPrice = 100;
            m_ccy = ttRow.CCY;
            //.CCY
            m_dDate = m_evalDate;
            // bond.DDATE
            m_dealid = ttRow.TTNo.ToString();
            //bond.DEALID
            m_Issuer = "N/A";
            //bond.SECURITY.Trim '.strShortName
            m_mDate = (DateTime)ttRow.Maturity;
            //MDATE
            m_sDate = (DateTime)ttRow.SettlementDate;
            // m_evalDate ' bond.VDATE
            m_DealText = "";
            // bond.DEALTEXT.Trim

            m_CouponType = "ASW";
            m_ASWP_Spread = (double)ttRow.Premium / 10000;
            //bond.ASWPSPRD / 100
            m_Spread = m_ASWP_Spread;

            m_DM = _parPremium;
            // pxInput.DM
            m_RevalSpreadDate = m_evalDate;
            // m_ABSEvalCurve.CurveDate

            // the bond cf collection is actually a CDSCFCollecton...
            //m_CashFlows = New mxCDSCFCollection(Me, cal, yc, m_sDate)
            m_CashFlows = new mxCDSCFlows(this, cal, yc, m_sDate);
            // m_evalDate)
            // NOTE: After the CPV cashflows are not used for these Tranches
            m_DM_CPV = _parPremium;
            //.InterpSpreadYRS(WALcpv)
            RecalcDMFlows();
        }


        public double CurrentFactor()
        {
            foreach (mxCDSCF cf in m_CashFlows)
            {
                if (cf.CFStart <= m_evalDate & m_evalDate < cf.CFEnd)
                {
                    return cf.NAmt / m_AmtOrig;
                }
            }

            return 1;
        }


        public double FlatIndex
        {
            get { return m_FlatIndex; }
        }



        public string CouponType
        {
            get { return m_CouponType; }
        }

        public string Ticker
        {
            get { return m_Ticker; }
        }


        public string AssetSubClass
        {
            get { return m_AssetSubClass; }
        }


        public string AssetClass
        {
            get { return m_AssetClass; }
        }


        public string WRAP
        {
            get { return m_Wrap; }
        }


        public double AswSprd
        {
            get { return m_ASWP_Spread; }
        }


        public double PurchPrice
        {
            get { return m_OrigPrice; }
        }

        public double AvgOut
        {
            get
            {
                //mxCDSCF cf = default(mxCDSCF);
                int i = 0;
                double dTotal = 0;
                foreach (mxCDSCF cf in m_CashFlows)
                {
                    if (cf.NAmt > 0)
                    {
                        i = i + 1;
                        dTotal = dTotal + cf.NAmt;
                        if (cf.CFEnd >= m_evalDate) break; // TODO: might not be correct. Was : Exit For

                    }
                }
                if (i != 0)
                {
                    return dTotal / i;
                }
                else
                {
                    return 0;
                }
            }
        }


        public string InterpSpread
        {
            get { return string.Format("DM: {0:n} (CURVE: {1} DATE: {2:d})", this.m_ABSEvalCurve.InterpSpread(MaturityDate), m_ABSEvalCurve.ABSEvalCurveName, m_ABSEvalCurve.EvalDate); }
        }


        // DISCOUNT MARGIN STATED in Basis Points
        public double DM_BP
        {
            get { return m_DM; }

            set { m_DM = value; }
        }

        // SECOND DM used for CPV generated cashflows
        public double DM_cpv
        {
            get { return m_DM_CPV; }
            set { m_DM_CPV = value; }
        }


        public string CUSIP
        {
            get { return m_Cusip; }
        }


        public double AIPrice
        {
            get { return (AccruedInterest / OutAmt) * 100; }
        }


        // new using AvgOut for Amortizing bonds...
        public double TotalReturn
        {
            get
            {
                if (m_evalDate.Subtract(SettleDate).Days > 0)
                {
                    return HPBondPL * (365 / (double)m_evalDate.Subtract(SettleDate).Days / Math.Abs(AvgOut));
                }
                else
                {
                    return 0;
                }
            }
        }


        public int HPDaysCount
        {
            get { return EvalDate.Subtract(SettleDate).Days; }
        }


        public string HPDays
        {
            get { return string.Format("Fr: {0:d} to: {1:d}  {2} days", SettleDate, m_evalDate, EvalDate.Subtract(SettleDate).Days); }
        }


        public double HPBondCapGain
        {
            get { return (this.OutAmt * (this.CleanPrice - this.PurchPrice) / 100); }
        }


        public double HPBondPL
        {
            get { return this.HPPastCash + this.HPAccruedInterest + (this.OutAmt * (this.CleanPrice - this.PurchPrice) / 100); }
        }

        public double HPPastCash
        {
            get
            {
                double dTotal = 0;
                foreach (mxCDSCF cf in m_CashFlows)
                {
                    //If RateCode = "FIXED" Then
                    //    If cf.CFEnd < m_evalDate Then
                    //        dTotal = dTotal + (cf.NAmt * cf.DayCountFrac(Me.Basis, cf.CFStart, cf.CFEnd) * cf.BaseRate)
                    //    End If
                    //Else
                    //    If cf.CFEnd < m_evalDate Then
                    //        dTotal = dTotal + (cf.NAmt * cf.DayCountFrac(Me.Basis, cf.CFStart, cf.CFEnd) * cf.dSpread)
                    //    End If
                    //End If
                    if (cf.CFEnd <= m_evalDate)
                    {
                        dTotal = dTotal + (cf.NAmt * cf.DayCountFrac(cf.Basis, cf.CFStart, cf.CFEnd) * cf.dSpread);
                    }
                }
                return dTotal;
            }
        }



        // just the spread income on floaters or FIXED coupon on fixed bonds...
        // also we will pick up the correct outstanding amounts due from PAST cashflows that 
        // may have been amortizing...
        public double HPAccruedInterest
        {
            get
            {
                // find flow after evaldate...
                foreach (mxCDSCF cf in m_CashFlows)
                {
                    if (cf.CFEnd >= m_evalDate)
                    {
                        return cf.NAmt * cf.DayCountFrac(cf.Basis, cf.CFStart, m_evalDate) * cf.dSpread;
                    }
                }
                return 0;  // shouldn't occur...
            }
        }


        public double AccruedInterest
        {
            get
            {
                //mxCDSCF cf = null;
                foreach (var cf in m_CashFlows)
                {
                    if (cf.IsStub)
                    {
                        return cf.NAmt * cf.DayCountFrac(cf.Basis, cf.CFStart, m_evalDate) * cf.ProjectedCoupon;
                        //break; // TODO: might not be correct. Was : Exit For
                    }
                }
                return 0;  // should get here...
            }
        }


        public double CrBPV_cpv
        {
            get { return m_CrBPV_cpv; }
        }


        public double CrBPV
        {
            get { return m_CrBPV; }
        }





        // public subRoutine to calculate the PV of the bonds flows given a DM
        // DISCOUNT MARGIN CALCULATIONS
        // uses FLAT libors to discount forward coupons:  (Index+RM)/(1+Index+DM)
        // uses the values of m_DM and m_FlatIndex to perform DM calculation
        // the subroutine stores values to m_pv_dm_flows and calculates the
        // credit_bpv
        public void RecalcDMFlows(double _bpShift = 1)
        {
            double dmFlow = 0;
            double dmFlow2 = 0;


            if ((m_CashFlows != null))
            {
                foreach (mxCDSCF cf in m_CashFlows)
                {
                    {
                        if (cf.IsStub)
                        {
                            double thisFlow = (cf.PrinPayment + cf.NAmt * cf.DMFlatCoupon(m_BaseRate) * cf.DayCountFrac(cf.Basis, cf.CFStart, cf.CFEnd)) / Math.Pow((1 + (m_BaseRate + m_DM / 10000) * cf.DayCountFrac(cf.Basis, cf.CFStart, cf.CFEnd)), ((double)(cf.CFEnd.Subtract(EvalDate).Days) / ((double)cf.CFEnd.Subtract(cf.CFStart).Days)));
                            dmFlow += thisFlow;
                            dmFlow2 += (cf.PrinPayment + cf.NAmt * cf.DMFlatCoupon(m_BaseRate) * cf.DayCountFrac(cf.Basis, cf.CFStart, cf.CFEnd)) / Math.Pow((1 + (m_BaseRate + (m_DM + _bpShift) / 10000) * cf.DayCountFrac(cf.Basis, cf.CFStart, cf.CFEnd)), ((double)cf.CFEnd.Subtract(EvalDate).Days / (double)cf.CFEnd.Subtract(cf.CFStart).Days));
                            cf.DMFlow = thisFlow;
                        }
                        else if (cf.CFStart > EvalDate)
                        {
                            double thisFlow = (cf.PrinPayment + cf.NAmt * cf.DMFlatCoupon(m_FlatIndex) * cf.DayCountFrac(cf.Basis, cf.CFStart, cf.CFEnd)) / Math.Pow((1 + (m_FlatIndex + m_DM / 10000) * cf.DayCountFrac(cf.Basis, cf.CFStart, cf.CFEnd)), ((double)cf.CFEnd.Subtract(EvalDate).Days / (double)cf.CFEnd.Subtract(cf.CFStart).Days));
                            dmFlow += thisFlow;
                            dmFlow2 += (cf.PrinPayment + cf.NAmt * cf.DMFlatCoupon(m_FlatIndex) * cf.DayCountFrac(cf.Basis, cf.CFStart, cf.CFEnd)) / Math.Pow((1 + (m_FlatIndex + (m_DM + _bpShift) / 10000) * cf.DayCountFrac(cf.Basis, cf.CFStart, cf.CFEnd)), ((double)cf.CFEnd.Subtract(EvalDate).Days / (double)cf.CFEnd.Subtract(cf.CFStart).Days));
                            cf.DMFlow = thisFlow;
                        }
                    }
                }
                m_PVFlows = dmFlow;
                m_CrBPV = dmFlow2 - dmFlow;
            }

            // just in case 
            if ((m_CashFlows_CPV != null))
            {
                dmFlow = 0;
                dmFlow2 = 0;
                foreach (mxCDSCF cf in m_CashFlows_CPV)
                {
                    {
                        if (cf.IsStub)
                        {
                            double thisFlow = (cf.PrinPayment + cf.NAmt * cf.DMFlatCoupon(m_BaseRate) * cf.DayCountFrac(cf.Basis, cf.CFStart, cf.CFEnd)) / Math.Pow((1 + (m_BaseRate + m_DM_CPV / 10000) * cf.DayCountFrac(cf.Basis, cf.CFStart, cf.CFEnd)), ((double)cf.CFEnd.Subtract(EvalDate).Days / (double)cf.CFEnd.Subtract(cf.CFStart).Days));
                            dmFlow += thisFlow;
                            dmFlow2 += (cf.PrinPayment + cf.NAmt * cf.DMFlatCoupon(m_BaseRate) * cf.DayCountFrac(cf.Basis, cf.CFStart, cf.CFEnd)) / Math.Pow((1 + (m_BaseRate + (m_DM_CPV + _bpShift) / 10000) * cf.DayCountFrac(cf.Basis, cf.CFStart, cf.CFEnd)), ((double)cf.CFEnd.Subtract(EvalDate).Days / (double)cf.CFEnd.Subtract(cf.CFStart).Days));
                            // store the current DM Cashflow to class member

                            cf.DMFlow = thisFlow;
                        }
                        else if (cf.CFStart > EvalDate)
                        {
                            double thisFlow = (cf.PrinPayment + cf.NAmt * cf.DMFlatCoupon(m_FlatIndex) * cf.DayCountFrac(cf.Basis, cf.CFStart, cf.CFEnd)) / Math.Pow((1 + (m_FlatIndex + m_DM_CPV / 10000) * cf.DayCountFrac(cf.Basis, cf.CFStart, cf.CFEnd)), ((double)cf.CFEnd.Subtract(EvalDate).Days / (double)cf.CFEnd.Subtract(cf.CFStart).Days));

                            dmFlow += thisFlow;
                            dmFlow2 += (cf.PrinPayment + cf.NAmt * cf.DMFlatCoupon(m_FlatIndex) * cf.DayCountFrac(cf.Basis, cf.CFStart, cf.CFEnd)) / Math.Pow((1 + (m_FlatIndex + (m_DM_CPV + _bpShift) / 10000) * cf.DayCountFrac(cf.Basis, cf.CFStart, cf.CFEnd)), ((double)cf.CFEnd.Subtract(EvalDate).Days / (double)cf.CFEnd.Subtract(cf.CFStart).Days));

                            cf.DMFlow = thisFlow;
                        }
                    }
                }
                m_PVFlows_CPV = dmFlow;
                m_CrBPV_cpv = dmFlow2 - dmFlow;

            }
        }


        // old method NOW DEFUNCT
        //ReadOnly Property RecalcBondCashflows() As Double
        //    Get
        //        Dim total As Double = 0

        //        For Each cf As mxCDSCF In m_CashFlows
        //            If cf.CFEnd >= m_evalDate Then
        //                total += cf.BondCFPV
        //            End If
        //        Next
        //        Return total
        //    End Get
        //End Property


        public double CleanPrice
        {
            get { return DirtyPrice - AIPrice; }
        }

        // pv of cashflows (as booked in OPICS)
        public double PVBondCashFlows
        {
            get { return m_PVFlows; }
        }

        // PV of CPV generated cashflows
        public double PVBondCashFlows_CPV
        {
            get { return m_PVFlows_CPV; }
        }

        public double DirtyPrice_CPV
        {
            get { return (m_PVFlows_CPV / OutAmt) * 100; }
        }


        public double DirtyPrice
        {
            get { return (m_PVFlows / OutAmt) * 100; }
        }

        // mtm evaldate for settlement and discount basis calculations
        public System.DateTime EvalDate
        {
            get { return m_evalDate; }
            set { m_evalDate = value; }
        }


        //'recalc bond cashflows give a yc object...
        //Sub Recalc(ByVal yc As CYldCurve)

        //    For Each cf As mxCDSCF In m_CashFlows
        //        ' calc the discount factor given cfend and evaldate...
        //        cf.DF = yc.GetDF2(cf.CFEnd, m_evalDate)
        //    Next
        //End Sub

        public mxCDSCFlows CashFlows
        {
            get { return m_CashFlows; }
        }

        public mxCDSCFlows CashFlowsCPV
        {
            get { return m_CashFlows_CPV; }
        }

        public string Basis
        {
            get { return m_basis; }
            set { m_basis = value; }
        }

        public string RateCode
        {
            get { return m_ratecode; }
            set { m_ratecode = value; }
        }

        public string DealText
        {
            get { return m_DealText; }
            set { m_DealText = value; }
        }


        // not really needed...
        //public string ListView1
        //{
        //    get
        //    {
        //        char pad = '\0';
        //        pad = Convert.ToChar(" ");
        //        return m_Issuer.PadRight(36, pad) + m_mDate.ToShortDateString().PadLeft(11, pad) + Strings.Format(m_AmtOut, "##0,,.0").PadLeft(7, pad) + "MM " + Strings.Format(m_Spread * 100, "n").PadRight(7, pad) + m_dealid;
        //    }
        //}

        public double OutAmt
        {
            get { return m_AmtOut; }
            set { m_AmtOut = value; }
        }

        public double OrigAmt
        {
            get { return m_AmtOrig; }
            set { m_AmtOrig = value; }
        }

        public string DealID
        {
            get { return m_dealid; }
            set { m_dealid = value; }
        }


        public string Port
        {
            get { return m_port; }
            set { m_port = value; }
        }

        public string CCY
        {
            get { return m_ccy; }
            set { m_ccy = value; }
        }

        public string Issuer
        {
            get { return m_Issuer; }
            set { m_Issuer = value; }
        }

        public System.DateTime MaturityDate
        {
            get { return m_mDate; }
            set { m_mDate = value; }
        }

        public System.DateTime TradeDate
        {
            get { return m_dDate; }
            //dealdate
            set { m_dDate = value; }
        }

        public System.DateTime SettleDate
        {
            get { return m_sDate; }
            set { m_sDate = value; }
        }

        public double BaseRate
        {
            get { return m_BaseRate; }
            set { m_BaseRate = value; }
        }

        public double Spread
        {
            get { return m_Spread; }
            set { m_Spread = value; }
        }


        //public dsOUT.BondPXSummaryDataTable Display
        public List<BondPXSummary> Display
        {
            get
            {
                //dsOUT.BondPXSummaryDataTable dt = new dsOUT.BondPXSummaryDataTable();
                List<BondPXSummary> dt = new List<BondPXSummary>();

                //dt.TableName = "BondPXSummary";
                BondPXSummary row = new BondPXSummary();
                //dsOUT.BondPXSummaryRow row = dt.NewBondPXSummaryRow();
                {
                    row.Security = string.Format("{0}", m_Issuer);
                    row.CUSIP = string.Format("CUSIP: {0}", CUSIP);
                    // + " AssetClass: " + Me.AssetClass)
                    row.DEALID = DealID;
                    row.PriceInfo = string.Format("{0} {1}", CalcTimeStamp.ToShortDateString(), CalcTimeStamp.ToLongTimeString());
                    row.DirtyPrice = DirtyPrice;
                    row.CleanPrice = CleanPrice;
                    row.Coupon = string.Format("Index: {0:p5} RM: {1:p5} {2}", BaseRate, Spread, CouponType);
                    row.MTMSpread = DM_BP;
                    // InterpSpread
                    row.OrigPrice = PurchPrice;
                    row.Maturity = string.Format("WAL: {0}yrs. Legal Final: {1:d}", WAL, LegalFinalMaturity);
                    row.AmountOutstanding = OutAmt;
                    row.AmountMTM = OutAmt * row.DirtyPrice / 100;
                    row.AccruedInt = AccruedInterest;
                    row.CreditBPV = CrBPV;
                    row.WAL = WAL;
                    row.OrigPrice = PurchPrice;
                    row.CPV = CPV;
                    row.WALA = this.WALA;
                    row.Factor = CurrentFactor();
                }
                dt.Add(row); // dt.AddBondPXSummaryRow(row);
                return dt;
            }
        }

        //public dsOUT.BondPXSummaryDataTable DisplayCPV
        public List<BondPXSummary> DisplayCPV
        {
            get
            {
                //dsOUT.BondPXSummaryDataTable dt = new dsOUT.BondPXSummaryDataTable();
                List<BondPXSummary> dt = new List<BondPXSummary>();
                //dt.TableName = "BondPXSummary_CPV";
                //dsOUT.BondPXSummaryRow row = dt.NewBondPXSummaryRow();
                BondPXSummary row = new BondPXSummary();
                {
                    row.Security = string.Format("{0}", m_Issuer);
                    row.CUSIP = string.Format("CUSIP: {0}", CUSIP);
                    // 
                    row.DEALID = DealID;
                    row.PriceInfo = string.Format("DM FLAT INDEX: {0:p5}", FlatIndex);
                    row.DirtyPrice = DirtyPrice_CPV;
                    row.CleanPrice = DirtyPrice_CPV;
                    // they are the same here... there is no accrued Int when I generate flows
                    row.Coupon = string.Format("Index: {0:p5} RM: {1:p5} {2}", BaseRate, Spread, CouponType);
                    row.MTMSpread = DM_cpv;
                    row.OrigPrice = PurchPrice;
                    row.Maturity = string.Format("WAL: {0:n}yrs. Legal Final: {1:d}", WALcpv, LegalFinalMaturity);
                    row.AmountOutstanding = OutAmt;
                    row.AmountMTM = OutAmt * row.DirtyPrice / 100;
                    row.AccruedInt = 0;
                    // there is no accrued interest
                    row.CreditBPV = CrBPV_cpv;
                    row.WAL = WALcpv;
                    row.OrigPrice = PurchPrice;
                    row.CPV = CPV;
                    row.WALA = WALA;
                    row.Factor = CurrentFactor();
                }
                dt.Add(row); // dt.AddBondPXSummaryRow(row);
                return dt;
            }
        }


        public double WAL
        {
            get
            {
                double dTotalWAL = 0;
                double dTotalWALFac = 0;
                try
                {
                    foreach (mxCDSCF cf in m_CashFlows)
                    {
                        if (cf.CFEnd >= m_evalDate)
                        {
                            dTotalWAL += cf.PrinPayment;
                            dTotalWALFac += cf.PrinPayment * (double)cf.CFEnd.Subtract(m_evalDate).Days / 365;
                        }
                    }

                    return dTotalWALFac / dTotalWAL;
                }
                catch
                {
                    return 0;
                }
            }
        }

        /// <summary>
        /// returns WAL in years from CPV (class Paydown Vector)
        /// </summary>
        /// <returns></returns>
        public double WALcpv
        {
            get
            {
                double dTotalWAL = 0;
                double dTotalWALFac = 0;

                // working with generated
                try
                {
                    foreach (mxCDSCF cf in m_CashFlows_CPV)
                    {
                        if (cf.CFEnd >= m_evalDate)
                        {
                            dTotalWAL += cf.PrinPayment;
                            dTotalWALFac += cf.PrinPayment * (double)cf.CFEnd.Subtract(m_evalDate).Days / 365;
                        }
                    }

                    return dTotalWALFac / dTotalWAL;
                }
                catch
                {
                    return 0;
                }
            }
        }

        public DateTime FirstSettleDate
        {
            get { return m_FirstSettleDate; }
        }

        public DateTime LegalFinalMaturity
        {
            get { return m_LegalFinal; }
        }

        public System.DateTime CalcTimeStamp
        {
            get { return m_CalcTime; }
            set { m_CalcTime = value; }
        }



        public string CPV
        {
            get { return m_cpv; }
        }


        public string Ratings
        {
            get { return m_Ratings; }
        }

        // new July 08,  track CPV Proforma pricing...
        public bool Amortizer
        {
            get { return m_AmortStatus; }
            set { m_AmortStatus = value; }
        }


        // new July 08,  track CPV Proforma pricing...
        public DateTime ProFormaDate
        {
            get { return m_ProFormaDate; }

            set { m_ProFormaDate = value; }
        }


        //Private Sub Generate_CPR_CashFlows(ByVal p_OPICSDealID As String, ByVal p_CPV As String, ByVal tkCalendar As tkReadMarketPricing.CCalendar, ByVal p_BondSettle As Date) ' As dsOPICS.OPICSDealCashFlowsDataTable
        //    'Dim ta As New dsOPICSTableAdapters.OPICSLIVEDEALTableAdapter
        //    'Dim dt As dsOPICS.OPICSLIVEDEALDataTable = ta.GetDataByDealID(p_OPICSDealID)
        //    'Dim bondRow As dsOPICS.OPICSLIVEDEALRow = dt.Rows(0)
        //    Dim iCpnPA As Integer
        //    Dim iRollDay As Integer = m_mDate.Day

        //    ' added Feb 04 2008,  if we are backdating, we need to get the 'current face' from the schedule table in opics based upon the date given 
        //    Dim taFlows As New dsOPICSTableAdapters.OPICSDealCashFlowsTableAdapter
        //    ' look up the deal by BR and Dealno and SettleDate to 'backdate the prinamt if needed
        //    Dim dblOrigFace As Double = taFlows.GetSecurityOutstanding(p_OPICSDealID.Substring(0, 2), p_OPICSDealID.Substring(3, 7), p_BondSettle, p_BondSettle)


        //    ' for now this will do assume all RMBS is on a 1Month schedule
        //    ' all others are quaterly or asset swapped quarterly
        //    If bondRow.SECURITYCLASS.ToString.StartsWith("RMBS") Or bondRow.SECURITYCLASS.ToString.StartsWith("CMBS") Then
        //        iCpnPA = 12 ' monthly
        //    Else
        //        iCpnPA = 4  ' quarterly
        //    End If


        //    'Dim dtLockOut As Date = bondRow.SETTLED.AddMonths(p_nMonthsLockout)
        //    Dim iWALA As Integer = DateDiff(DateInterval.Month, bondRow.SETTLED, p_BondSettle)
        //    Dim dCPV As Double() = Me.GetCPV(p_CPV) ' ie p_CPV looks like: '20.5 for 6, 30 for 12, 40 for 12, 40'

        //    Dim l As Integer = iWALA



        //    ' begin by creating the dynamically allocated cashflows find front stub
        //    Dim dtFlowBegin As Date
        //    Dim dtFlowEnd As Date

        //    ' start from maturity date backwards to allign front stub with maturity date
        //    dtFlowBegin = bondRow.MATURITY
        //    Dim iCtr As Integer = 1
        //    Do While dtFlowBegin > p_BondSettle
        //        dtFlowEnd = dtFlowBegin
        //        ' create monthly/qtrly cashflows by rolling backward from maturity date...
        //        ' this will be holiday sensitive w/ modified following
        //        dtFlowBegin = bondRow.MATURITY.AddMonths(-iCtr * CInt((12 / iCpnPA)))
        //        iCtr += 1
        //    Loop

        //    ' ensure iRollDate day of month will match that of the maturity...
        //    Dim iRollDate As Date = dtFlowEnd
        //    If iRollDate.Day <> iRollDay Then
        //        iRollDate = DateSerial(iRollDate.Year, iRollDate.Month, iRollDay)
        //    End If

        //    Dim dtFlows As New dsOPICS.OPICSDealCashFlowsDataTable

        //    Dim dNextAmt = dblOrigFace
        //    iCtr = 0
        //    dtFlowBegin = p_BondSettle  'eliminate the accrued interest prior to settlement
        //    Do While dNextAmt > 0.01
        //        Dim newFlow As dsOPICS.OPICSDealCashFlowsRow = dtFlows.NewOPICSDealCashFlowsRow
        //        With newFlow
        //            .PRINAMT = dNextAmt

        //            If bondRow.FACE <> 0 Then .FACTOR = .PRINAMT / bondRow.FACE

        //            .INTSTRTDTE = dtFlowBegin
        //            If iCtr = 0 Then
        //                .INTENDDTE = dtFlowEnd ' front stub end date found earlier...
        //            Else
        //                .INTENDDTE = tkCalendar.FwdDate(iRollDate, CShort(iCtr * CInt(12 / iCpnPA)))
        //            End If
        //            .IPAYDATE = .INTENDDTE


        //            If (dNextAmt < dblOrigFace / 25) Or (iCtr * CInt(12 / iCpnPA) > 359) Then ' 1% Cleanup Call or 30years
        //                .PPAYAMT = dNextAmt
        //            Else
        //                .PPAYAMT = System.Math.Round(.PRINAMT * ((dCPV(l) / 100) / iCpnPA), 2)
        //                .CPR = dCPV(l)
        //            End If
        //            dNextAmt -= .PPAYAMT



        //            ' roll date for next flow...
        //            dtFlowBegin = .INTENDDTE

        //            If bondRow.ASWPSPRD = 0 Then
        //                .SPREAD = bondRow.SPREAD / 100
        //            Else
        //                .SPREAD = bondRow.ASWPSPRD / 100
        //            End If

        //            .BASIS = "A360"
        //            .CCY = bondRow.CCY
        //            .BR = p_OPICSDealID.Substring(0, 2)
        //            .DEALNO = p_OPICSDealID.Substring(3, 7)
        //            iCtr = iCtr + 1
        //            ' l is the index of the iCPV array a monthly (0-359) vector of CPRs
        //            l += CInt(12 / iCpnPA)
        //        End With
        //        dtFlows.AddOPICSDealCashFlowsRow(newFlow)
        //    Loop
        //    Return dtFlows
        //End Sub


        /// <summary>
        /// return outstandig amount from flows on a given date
        /// </summary>
        /// <param name="dateOut"></param>
        /// <returns></returns>
        public double OutstandingOn(DateTime dateOut)
        {
            // LINQ!
            return (from f in m_CashFlows
                    where f.CFStart <= dateOut && f.CFEnd > dateOut
                    select f.NAmt).SingleOrDefault();

            //mxCDSCF cf = default(mxCDSCF);
            //foreach (var cf in m_CashFlows)
            //{
            //    if (cf.CFStart <= dateOut & cf.CFEnd > dateOut)
            //    {
            //        dAmt = cf.NAmt;
            //        break; // TODO: might not be correct. Was : Exit For
            //    }
            //}
            ////
            //return dAmt;
        }


        // return the # of months from orig settle date to the evaluation date...
        public int WALA
        {
            get
            {
                int monthsApart = 12 * (m_FirstSettleDate.Year - m_evalDate.Year) + m_FirstSettleDate.Month - m_evalDate.Month;
                return Math.Abs(monthsApart);
            }
        }
    }
    // OpicsBond Class ends here
}